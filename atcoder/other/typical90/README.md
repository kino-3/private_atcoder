# 競プロ典型 90 問

[問題](https://atcoder.jp/contests/typical90)

## 001: 答で二分探索

- 10: 二分探索に気付く(最初 DP で考えていた)
- 20: 実装
- 35: デバッグ

解法は同じ。入力変数を global 変数にすれば作ったライブラリがそのまま活用できた。

## 002: bit 全探索

- 1: n==20 なので全探索でよいことに気付く
- 10: 実装(この形式の loop を書いたことがなかったので手間取る)
- 14: デバッグ(continueが内側loopしか抜け出せていなかった -> flg)

解法は同じ。「(i & (1 << j)) = 0 というのは、i の j ビット目（2^j の位）が 0 であるための条件」に気付かなかったが, bitset の方が分かりやすい気がする。

## 003: 木の直径

- 1: 重心分解 + 分割統治法
- 重心分解の自作ライブラリのバグに気付く(バグ修正済み)
- 想像以上に分割統治が大変なことに気付く
- LCA と同じイメージでいけることに気付く
- よくありそうなので, 自作ライブラリに追加

別解法。木の直径(木の最長経路) は最短距離計算を 2 回やれば解けるらしい。

1. 任意の点(X)から最も遠い点(A)を探索(BFSなど)する
2. A から最も遠い点(B)を探索(BFSなど)する

このとき, A-B が最長経路(の1つ)となる。

証明

任意の点(X)から最も遠い点がA'(≠A)とする。X を取り除いたとき, AとBが異なる部分木にあるなら, A'-B が A-B より長くなり矛盾。AとBが同じ部分木にあるなら, X で吊ったときのAとBのLCAをYとすると, A-Y よりも Y-X-A' の方が長く, A'-X-Y-B が A-Y-B より長くなり矛盾。

## 004

- 1: 解法
- 10: 実装(データ読み込み部分を作るのに時間がかかった)

解法は同じ。

## 005

- 10: 連立2項間漸化式 + 行列累乗
- 50: 実装(途中)
- 60: 計算量的に B < 1000 は厳しい。sparse なので他の手法がある?

pass

## 006: 辞書順最小(前から貪欲に)

- 1: 接尾辞配列
- 8: 部分文字列の定義を勘違いしていたことに気付く
- 10: dp?
- 15: stack
- 25: 実装
- 40: デバッグ

無限ループのデバッグに手間取った。
別解法。解答は `A[idx][c]` 部分文字列 `S[idx:]` 中の文字 `c` のうち最も左の idx を前計算

## 007

- 1: 二分探索
- 8: 実装
- 13: デバッグ

同解法。loop index に cin で代入していた。

## 008: 状態DP

- 1: 最大流
- 2: dp
- 8: 実装

同解法。

## 009

- 5: グラフ or 分割統治
- 14: 中心決めて sort して しゃくとり -> O(N^2 logN)
- 27: 実装
- 35: デバッグ ( M_PI - abs(M_PI - arg) が間違っていた)
- 36: WA (小数の出力精度が足らなかった)
- 38: AC

ほぼ同解法。sort の後が二分探索かしゃくとりかだけの違い。

## 010: 累積和

- 1: 累積和
- 7: 実装
- 15: デバッグ (index の間違い)

同解法。

## 011: 締め切りの早い順にsortしてからDP

- 3: dp
- 9: 実装
- 14: dpを後ろから回す必要がある(同じ仕事を何回もやる)
- 21: 最初に締め切りでsortが必要

ほぼ同解法。自分の解答は dp[d] を時間 d までの最大報酬としたが(つまりdpは単調増加), 解答では dp[1] から dp[d] までの最大値を時間 d までの最大報酬とし, dp の更新式が簡単になる方法で解いていた。

## 012: Union Find

- 2: union-find 木
- 15: 実装
- 25: indexのバグ修正

同解法。

## 013: Dijkstra

- 2: Dijkstra 2 回
- 7: 実装

同解法。

## 014

- 1: 貪欲法
- 4: 実装

同解法。

## 015

- 5: 平方分割?

pass

## 016: 全探索

- 2: 二重 for で間に合う (10^8)
- 8: 実装(一番大きなコインの枚数は最多 -> WA)
- 17: シンプルな二重 for (打ち切りなし)

同解法。

## 017

pass

## 018

- 2: ただの幾何計算
- 11: 実装
- 14: デバッグ(直径と半径を間違えていた)

## 019

pass

## 020: 整数で処理できるときは整数で処理する

- 2: 実装

同解法。

## 021: 強連結成分分解

- 1: 強連結成分分解
- 6: 実装

同解法。

## 022

- 2: 実装

同解法。

## 023

pass

## 024: パリティを考える

- 4: 実装

同解法。

## 025

pass

## 026

- 1: 二色に塗って少なくないほう
- 3: ある頂点で吊ったときの深さが偶数か奇数かで少なくないほう
- 15: 実装
- 30: Tree ライブラリのバグ修正

類似解法。木は必ず 2 部グラフ。
TODO: ./lib_arihon/graph/tree.cpp の修正

## 027

- 1: set
- 4: 実装

同解法。

## 028: いもす法

- 2: 2次元BIT(範囲版)
- 5: いもす法
- 25: 実装
- 30: デバッグ(変数名j1は使用できない?)

いもす法を実装をしたことがなかったので手間取った。

## 029

- 1: 遅延セグメント木

pass (あとで実装する)

## 030

- 1: K == 1 のとき N - 1
- 5: エラトステネスの篩?
- 10: 単純な素数判定でも微妙に TLE する -> K == 2 が解けない
- 40: 調べたところ, この程度の個数であればエラトステネスの篩の方が高速らしい -> 計算時間としては OK
- 45: エラトステネスの篩のコードをわずかに改変すればよいことに気付く
- 50: 実装

ほぼ同解法。エラトステネスの篩の計算量は O(N loglogN) らしい。

## 031: grundy 数

- 3: Nim
- 25: 実装(TLE)
- 60: 実装(同じ計算をしているところを削除)

ほぼ同解法。公式解答は 10 倍速いらしい。違いは mex の計算で, 自解法は set をつかっているが, 公式解答は vector (0 から「手数の最大値」までの配列にフラグを立てて, 最初にフラグがない位置が grundy 数)を使っている。

- grundy 数は 1 手でいける全ての状態の grundy 数に含まれない最小の非負整数(mex)
- grundy 数が 0 なら後手必勝, 1 なら先手必勝
- 複数の山があるときは xor をとる

## 032: 順列全探索

- 1: 順列全探索
- 25: 実装

同解法。

## 033

- 1: 解法
- 2: 実装
- 5: 実装(幅1のコーナーケース)

同解法。

## 034

- 1: しゃくとり
- 15: 実装
- 23: 個数のカウントが必要なことに気付く
- 33: 実装

## 035

pass

## 036: マンハッタン距離

- 5: 凸包の外側を二分探索?
- 15: 四隅の4点を考えればよい
- 23: 実装

ほぼ同解法。マンハッタン距離は 45 度回転 (X=x-y, Y=x+y) する。
このとき, 2点のマンハッタン距離はそれぞれの座標で

- abs(x1-x2) + abs(y1-y2)
- max(abs(X1-X2), abs(Y1-Y2))

と表され(マンハッタン距離が定数kの領域を考えると分かりやすい),
後者は X, Y を独立に処理できる。

## 037: DP + セグメント木

- 1: DP
- 3: O(NW^2)
- 6: セグメント木で O(NW log W)
- 22: 実装

同解法。

## 038

- 実装
- バグ修正(整数除算,問題文読み間違い)

同解法。

## 039: edge の答への貢献度(主客転倒)

- 2: 距離をO(1)で出しても間に合わない
- 6: 全ての edge について, edge を取り除いた両側の頂点数の積の総和
- 22: 現状の木再帰のライブラリが肥大化して使いづらいので, 最小構成のライブラリを再作成
- 27: 実装

同解法。

## 040

pass

## 041

pass

## 042

- 4: 2^K-1
- 6: 桁の数字が 9 を超えることに気付く
- 9: dp
- 19: 実装

自解答では先頭数字で場合分けして dp をしたが, 解答では [A][総和K-Aの整数] として総和 K の整数を考えていた。

## 043: 拡張 BFS

- 1: bfs
- 20: 実装 TLE
- 31: 同じマスを同じ方向に2回以上探索しないようにする。

別解法。模範解答ではグラフで解いていた。

## 044

- 2: 先頭管理
- 8: 実装

同解法。

## 045

pass

## 046

- 1: O(46**3)
- 6: 実装

同解法。

## 047

pass

## 048

- 1: 貪欲
- 4: コンパイルエラー (変数名 data の競合?)
- 6: 実装

同解法。

## 049

pass

## 050

- 1: dp
- 4: 実装
- 6: デバッグ(modを途中計算に入れないでオーバーフローしていた)

## 051

- 2: 半分全列挙
- 70: 実装
- 90: RE 以外解消

RE が解消できない。pass

## 052

- 1: 解法
- 3: 実装

同解法。

## 053

pass

## 054

pass

## 055

- 2: 解法
- 6: 実装
- 17: デバッグ(A[k] を k とするミス)

同解法。

## 056: DP 復元

- 1: dp
- 21: 実装(デバッグに時間がかかった)

別解法。自解法では bool のかわりに経路情報を保存したが, 模範解答は bool を保存して, 最後に逆順に true を辿って復元している(dp は2次元)。

## 057

pass

## 058

- 1: 周期性
- 12: 実装
- 17: 1周期回ったときに途中に合流しうることに気付く
- 22: 実装

ほぼ同解法。

## 059

pass

## 060: 最長部分増加列

- 2: 最長増加部分列
- 6: 実装開始
- 20: 併合するために, dp の履歴の保存が必要?
- 28: 頂点を決めて, その頂点までの長さを計算する O(N log N) で計算可能
- 33: 実装: WA
- 41: 実装(dp を A と書き間違えていた)

同解法。

## 061

- 1: deque
- 4: 実装

同解法。

## 062

pass

## 063

- 1: H 方向に bit 全探索で間に合いそう
- 20: 実装

同解法。個数カウントの実装に手間取った。

## 064

- 2: 差を考える
- 9: 実装

## 065

pass

## 066: 期待値の線形性

- 3: O(N^2)
- 10: 区間の配置は (i,i,j,j) の 4C2 = 6 パターン存在する。 (i,j,j,i) なら, j の区間は i の区間に包含される。
- 28: 実装

ほぼ同解法。場合分けしなくても, O(N^4) でもいける。

## 067

- 1: 解法
- 10: 実装 WA
- 30: N の上限制約が 10 進数表記においてでなく, オーバーフローしている可能性?
- 37: 実装 WA
- 39: 0 のとき空文字列を出力していることに気付く
- 43: 実装

同解法。色々はまって★2問題と思えないほど苦戦した。

- 3項演算子の a ? b : c の b, c の型が同じでないといけない
- string 型の Str について, Str[0] は char 型で, '3' を 3 にするには '3' - '0' とする。

## 068: クエリ先読み

- 5: グラフ?
- 9: T_i == 0 で隣り合う制約から, union find と binary indexed tree でいける
- 18: 実装
- 54: BIT ライブラリバグ修正(分かりにくいので 0-indexed にした)
- 55: 実装 (WA)
- 62: 実装 (同じ情報が2回与えられていた, BIT は add なのでリセットが必要であった)

Ambiguous は同解法。区切りを探す set を使った別解もある。
値の計算は別解法。自解法の BIT は O(Q logN) だが, クエリ先読み(特定のクエリ(今回ならT_i==0)を先に処理する) なら O(Q) となる。

## 069: 繰り返し二乗法

- 1: 式
- 4: 実装 (TLE)
- 8: mod pow

同解法。

## 070: 距離の絶対値の総和は中央値で最小になる

- 1: 解法
- 4: 実装

同解法。

## 071

pass

## 072

- 20: 二部グラフ? DFS では間に合わなそう

pass

## 073

- 3: 木DP?

pass

## 074

pass

## 075

- 2: log2(素因数の数)
- 6: 実装

同解法。
