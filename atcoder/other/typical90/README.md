# 競プロ典型 90 問

https://atcoder.jp/contests/typical90

## 001: 答で二分探索

- 10: 二分探索に気付く(最初 DP で考えていた)
- 20: 実装
- 35: デバッグ

解法は同じ。入力変数を global 変数にすれば作ったライブラリがそのまま活用できた。

## 002: bit 全探索

- 1: n==20 なので全探索でよいことに気付く
- 10: 実装(この形式の loop を書いたことがなかったので手間取る)
- 14: デバッグ(continueが内側loopしか抜け出せていなかった -> flg)

解法は同じ。「(i & (1 << j)) = 0 というのは、i の j ビット目（2^j の位）が 0 であるための条件」に気付かなかったが, bitset の方が分かりやすい気がする。

## 003: 木の直径

- 1: 重心分解 + 分割統治法
- 重心分解の自作ライブラリのバグに気付く(バグ修正済み)
- 想像以上に分割統治が大変なことに気付く
- LCA と同じイメージでいけることに気付く
- よくありそうなので, 自作ライブラリに追加

別解法。木の直径(木の最長経路) は最短距離計算を 2 回やれば解けるらしい。

1. 任意の点(X)から最も遠い点(A)を探索(BFSなど)する
2. A から最も遠い点(B)を探索(BFSなど)する

このとき, A-B が最長経路(の1つ)となる。

証明

任意の点(X)から最も遠い点がA'(≠A)とする。X を取り除いたとき, AとBが異なる部分木にあるなら, A'-B が A-B より長くなり矛盾。AとBが同じ部分木にあるなら, X で吊ったときのAとBのLCAをYとすると, A-Y よりも Y-X-A' の方が長く, A'-X-Y-B が A-Y-B より長くなり矛盾。

## 004

- 1: 解法
- 10: 実装(データ読み込み部分を作るのに時間がかかった)

解法は同じ。

## 005

- 10: 連立2項間漸化式 + 行列累乗
- 50: 実装(途中)
- 60: 計算量的に B < 1000 は厳しい。sparse なので他の手法がある?

pass

## 006: 辞書順最小(前から貪欲に)

- 1: 接尾辞配列
- 8: 部分文字列の定義を勘違いしていたことに気付く
- 10: dp?
- 15: stack
- 25: 実装
- 40: デバッグ

無限ループのデバッグに手間取った。
別解法。解答は `A[idx][c]` 部分文字列 `S[idx:]` 中の文字 `c` のうち最も左の idx を前計算

## 007

- 1: 二分探索
- 8: 実装
- 13: デバッグ

同解法。loop index に cin で代入していた。

## 008: 状態DP

- 1: 最大流
- 2: dp
- 8: 実装

同解法。

## 009

- 5: グラフ or 分割統治
- 14: 中心決めて sort して しゃくとり -> O(N^2 logN)
- 27: 実装
- 35: デバッグ ( M_PI - abs(M_PI - arg) が間違っていた)
- 36: WA (小数の出力精度が足らなかった)
- 38: AC

ほぼ同解法。sort の後が二分探索かしゃくとりかだけの違い。

## 010: 累積和

- 1: 累積和
- 7: 実装
- 15: デバッグ (index の間違い)

同解法。
