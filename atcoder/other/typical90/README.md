# 競プロ典型 90 問

[問題](https://atcoder.jp/contests/typical90)

## 001: 答で二分探索

- 10: 二分探索に気付く(最初 DP で考えていた)
- 20: 実装
- 35: デバッグ

解法は同じ。入力変数を global 変数にすれば作ったライブラリがそのまま活用できた。

## 002: bit 全探索

- 1: n==20 なので全探索でよいことに気付く
- 10: 実装(この形式の loop を書いたことがなかったので手間取る)
- 14: デバッグ(continueが内側loopしか抜け出せていなかった -> flg)

解法は同じ。「(i & (1 << j)) = 0 というのは、i の j ビット目（2^j の位）が 0 であるための条件」に気付かなかったが, bitset の方が分かりやすい気がする。

## 003: 木の直径

- 1: 重心分解 + 分割統治法
- 重心分解の自作ライブラリのバグに気付く(バグ修正済み)
- 想像以上に分割統治が大変なことに気付く
- LCA と同じイメージでいけることに気付く
- よくありそうなので, 自作ライブラリに追加

別解法。木の直径(木の最長経路) は最短距離計算を 2 回やれば解けるらしい。

1. 任意の点(X)から最も遠い点(A)を探索(BFSなど)する
2. A から最も遠い点(B)を探索(BFSなど)する

このとき, A-B が最長経路(の1つ)となる。

証明

任意の点(X)から最も遠い点がA'(≠A)とする。X を取り除いたとき, AとBが異なる部分木にあるなら, A'-B が A-B より長くなり矛盾。AとBが同じ部分木にあるなら, X で吊ったときのAとBのLCAをYとすると, A-Y よりも Y-X-A' の方が長く, A'-X-Y-B が A-Y-B より長くなり矛盾。

## 004

- 1: 解法
- 10: 実装(データ読み込み部分を作るのに時間がかかった)

解法は同じ。

## 005

- 10: 連立2項間漸化式 + 行列累乗
- 50: 実装(途中)
- 60: 計算量的に B < 1000 は厳しい。sparse なので他の手法がある?

pass

## 006: 辞書順最小(前から貪欲に)

- 1: 接尾辞配列
- 8: 部分文字列の定義を勘違いしていたことに気付く
- 10: dp?
- 15: stack
- 25: 実装
- 40: デバッグ

無限ループのデバッグに手間取った。
別解法。解答は `A[idx][c]` 部分文字列 `S[idx:]` 中の文字 `c` のうち最も左の idx を前計算

## 007

- 1: 二分探索
- 8: 実装
- 13: デバッグ

同解法。loop index に cin で代入していた。

## 008: 状態DP

- 1: 最大流
- 2: dp
- 8: 実装

同解法。

## 009

- 5: グラフ or 分割統治
- 14: 中心決めて sort して しゃくとり -> O(N^2 logN)
- 27: 実装
- 35: デバッグ ( M_PI - abs(M_PI - arg) が間違っていた)
- 36: WA (小数の出力精度が足らなかった)
- 38: AC

ほぼ同解法。sort の後が二分探索かしゃくとりかだけの違い。

## 010: 累積和

- 1: 累積和
- 7: 実装
- 15: デバッグ (index の間違い)

同解法。

## 011: 締め切りの早い順にsortしてからDP

- 3: dp
- 9: 実装
- 14: dpを後ろから回す必要がある(同じ仕事を何回もやる)
- 21: 最初に締め切りでsortが必要

ほぼ同解法。自分の解答は dp[d] を時間 d までの最大報酬としたが(つまりdpは単調増加), 解答では dp[1] から dp[d] までの最大値を時間 d までの最大報酬とし, dp の更新式が簡単になる方法で解いていた。

## 012: Union Find

- 2: union-find 木
- 15: 実装
- 25: indexのバグ修正

同解法。

## 013: Dijkstra

- 2: Dijkstra 2 回
- 7: 実装

同解法。

## 014

- 1: 貪欲法
- 4: 実装

同解法。

## 015

- 5: 平方分割?

pass

## 016: 全探索

- 2: 二重 for で間に合う (10^8)
- 8: 実装(一番大きなコインの枚数は最多 -> WA)
- 17: シンプルな二重 for (打ち切りなし)

同解法。

## 017

pass

## 018

- 2: ただの幾何計算
- 11: 実装
- 14: デバッグ(直径と半径を間違えていた)

## 019

pass

## 020: 整数で処理できるときは整数で処理する

- 2: 実装

同解法。

## 021: 強連結成分分解

- 1: 強連結成分分解
- 6: 実装

同解法。

## 022

- 2: 実装

同解法。

## 023

pass

## 024: パリティを考える

- 4: 実装

同解法。

## 025

pass

## 026

- 1: 二色に塗って少なくないほう
- 3: ある頂点で吊ったときの深さが偶数か奇数かで少なくないほう
- 15: 実装
- 30: Tree ライブラリのバグ修正

類似解法。木は必ず 2 部グラフ。
TODO: ./lib_arihon/graph/tree.cpp の修正

## 027

- 1: set
- 4: 実装

同解法。

## 028: いもす法

- 2: 2次元BIT(範囲版)
- 5: いもす法
- 25: 実装
- 30: デバッグ(変数名j1は使用できない?)

いもす法を実装をしたことがなかったので手間取った。

## 029

- 1: 遅延セグメント木

pass (あとで実装する)

## 030

- 1: K == 1 のとき N - 1
- 5: エラトステネスの篩?
- 10: 単純な素数判定でも微妙に TLE する -> K == 2 が解けない
- 40: 調べたところ, この程度の個数であればエラトステネスの篩の方が高速らしい -> 計算時間としては OK
- 45: エラトステネスの篩のコードをわずかに改変すればよいことに気付く
- 50: 実装

ほぼ同解法。エラトステネスの篩の計算量は O(N loglogN) らしい。

## 031: grundy 数

- 3: Nim
- 25: 実装(TLE)
- 60: 実装(同じ計算をしているところを削除)

ほぼ同解法。公式解答は 10 倍速いらしい。違いは mex の計算で, 自解法は set をつかっているが, 公式解答は vector (0 から「手数の最大値」までの配列にフラグを立てて, 最初にフラグがない位置が grundy 数)を使っている。

- grundy 数は 1 手でいける全ての状態の grundy 数に含まれない最小の非負整数(mex)
- grundy 数が 0 なら後手必勝, 1 なら先手必勝
- 複数の山があるときは xor をとる

## 032: 順列全探索

- 1: 順列全探索
- 25: 実装

同解法。

## 033

- 1: 解法
- 2: 実装
- 5: 実装(幅1のコーナーケース)

同解法。

## 034

- 1: しゃくとり
- 15: 実装
- 23: 個数のカウントが必要なことに気付く
- 33: 実装

## 035

pass

## 036: マンハッタン距離

- 5: 凸包の外側を二分探索?
- 15: 四隅の4点を考えればよい
- 23: 実装

ほぼ同解法。マンハッタン距離は 45 度回転 (X=x-y, Y=x+y) する。
このとき, 2点のマンハッタン距離はそれぞれの座標で

- abs(x1-x2) + abs(y1-y2)
- max(abs(X1-X2), abs(Y1-Y2))

と表され(マンハッタン距離が定数kの領域を考えると分かりやすい),
後者は X, Y を独立に処理できる。
