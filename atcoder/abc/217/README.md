# ABC 217

## 重要メモ

- B: N 個の整数の集合と, そこからいずれか 1 つを削除した N - 1 個の整数の集合が与えられたとき, 削除されたものの判定は O(N) でできる。
- D: lower_bound は「指定された要素『以上』の値が現れる最初の位置のイテレータ」
- F: 並べた 2N 個の要素のペアリング (制約: ペアリングがクロスしない (つまり, aabb や abba は OK だが, abab は NG)) -> 区間DP

## B

- N 個の整数の集合 A と, そこからいずれか 1 つを削除した N - 1 個の整数の集合 B が与えられたとき, 削除されたものの判定は O(N) でできる。
  - sum(A) - sum(B) でよい。
- 文字列の場合は整数に変換すれば同じ。

## D

- set に lower_bound をかますときは hoge.lower_bound(value)
- it の 1 つ前のイテレータは prev(it)
  - これはコピーを返す(参照を書き換えるのではない)
- 別解: 座標圧縮 + BIT で O(N)
  - S = sum([1, target]) を得る。
  - [1, 32] -> [1, 16] or [17, 32] -> ...... と下って和が S になる範囲を調べる
- 別解: Union-Find 木で逆順に結合していく? -> ABC 214

## E

- 面白い問題だった。

## F

- 区間 DP だとは思うが, 解法が思いつかない。PASS

## G

- n 個の球を m 個の箱に入れる場合の数
  - (球, 箱) が (区別可能, 区別可能) のとき -> m^n
  - (球, 箱) が (区別不能, 区別可能) のとき -> 球を 1 列に並べて仕切りの位置の combination
  - (球, 箱) が (区別可能, 区別不能) のとき -> 本問 (dp[i][j]: i番目の球までをj個に分割 )
  - (球, 箱) が (区別不能, 区別不能) のとき -> 分割数 (dp[i][j]: i個の球をj個に分割)
- 包除原理 + 畳み込み で O(N log N) で解けるらしい(未確認)
