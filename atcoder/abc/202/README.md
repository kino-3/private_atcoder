# ABC 202

## 重要メモ

- D: 辞書順 N 番目の問題は先頭から順に考えるのが定石

## B

- else をつけ忘れて 6 -> 9 -> 6 としていた

## D

- 組み合わせが long long に収まるときは, `n_C_r = n-1_C_r + n-1_C_r-1` を dp で考えるのが良い。(格子の道順と同じ考え方。)

## E

- 深さごとに頂点を vector で管理 (セグメント木と同様のイメージ) して, 祖先が Ui であるような区間の幅を二分探索で求める方針で解いた。O(Q (log N)^2 )
- 別解1
  - 上から頂点に入るとき, 上に頂点を出るときを合わせて数字を順に振る
    - ref. https://atcoder.jp/contests/abc202/editorial/1864
  - 次の 2 つは同値(頂点に入ってからその頂点を出るまでは, その頂点を根とする部分木を探索するので)
    - X に入る -> Y に入る -> X を出る
    - Y は X の子孫
  - 深さごとに, 入ったタイミングのリストを持って, 上の条件を満たす区間を二分探索で求める。
  - つまり, オイラーツアーで部分木を調べる問題
    - ref. https://blog.hamayanhamayan.com/entry/2017/04/10/163548
- 別解2
  - オイラーツアーで深さを値としてもつ vector を作る。Ui の部分木に対応して区間[L,R]が得られるので, その区間に値 D[i] がいくつあるかを数える。
    - クエリ先読みで深さ順に考えることで, この個数を数えることができる
    - Wavelet Matrix でもできると思う。
      - これ: https://atcoder.jp/contests/abc202/editorial/1906
- 別解3(https://kanpurin.hatenablog.com/entry/2021/05/22/231444)
  - オイラーツアーの順にクエリ先読み, ということだと思う。
    - これ: https://atcoder.jp/contests/abc202/editorial/1926
